{
    "summary": "The FilmConditioning layer is a deep learning implementation of FiLM conditioning technique for image processing, utilizing two dense layers and convolutional filters with conditioning tensor inputs.",
    "details": [
        {
            "comment": "This code defines a FilmConditioning layer that can be applied after a convolutional layer to learn FiLM conditioning, which is an image processing technique used in deep learning models. The class inherits from tf.keras.layers.Layer and contains the implementation of this technique.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_conditioning_layer.py\":0-29",
            "content": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"ResNet variants model for Keras with Film-Conditioning.\nRelated papers/blogs:\n- https://arxiv.org/abs/1512.03385\n- https://arxiv.org/pdf/1603.05027v2.pdf\n- http://torch.ch/blog/2016/02/04/resnets.html\n- https://arxiv.org/abs/1709.07871\n\"\"\"\nimport tensorflow.compat.v2 as tf\nlayers = tf.keras.layers\nclass FilmConditioning(tf.keras.layers.Layer):\n  \"\"\"Layer that adds FiLM conditioning.\n  This is intended to be applied after a convolutional layer. It will learn a"
        },
        {
            "comment": "FiLM conditioning layer with two dense layers for additive and multiplicative channel factors. Initializes weights to zero for better performance. Expects convolution filters and conditioning tensor as input.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_conditioning_layer.py\":30-61",
            "content": "  multiplicative and an additive factor to be applied to each channel of the\n  convolution's output.\n  Conv layer can be rank 2 or 4.\n  For further details, see: https://arxiv.org/abs/1709.07871\n  \"\"\"\n  def __init__(self, num_channels: int):\n    \"\"\"Constructs a FiLM conditioning layer.\n    Args:\n      num_channels: Number of filter channels to expect in the input.\n    \"\"\"\n    super().__init__()\n    # Note that we initialize with zeros because empirically we have found\n    # this works better than initializing with glorot.\n    self._projection_add = layers.Dense(\n        num_channels,\n        activation=None,\n        kernel_initializer='zeros',\n        bias_initializer='zeros')\n    self._projection_mult = layers.Dense(\n        num_channels,\n        activation=None,\n        kernel_initializer='zeros',\n        bias_initializer='zeros')\n  def call(self, conv_filters: tf.Tensor, conditioning: tf.Tensor):\n    tf.debugging.assert_rank(conditioning, 2)\n    projected_cond_add = self._projection_add(conditioning)\n    projected_cond_mult = self._projection_mult(conditioning)"
        },
        {
            "comment": "This code conditionally shapes the projected conditions and applies FiLM transformations to the convolutional filters, ensuring the initialization is centered at the identity transform.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_conditioning_layer.py\":63-73",
            "content": "    if len(conv_filters.shape) == 4:\n      # [B, D] -> [B, 1, 1, D]\n      projected_cond_add = projected_cond_add[:, tf.newaxis, tf.newaxis]\n      projected_cond_mult = projected_cond_mult[:, tf.newaxis, tf.newaxis]\n    else:\n      tf.debugging.assert_rank(conv_filters, 2)\n    # Original FiLM paper argues that 1 + gamma centers the initialization at\n    # identity transform.\n    result = (1 + projected_cond_mult) * conv_filters + projected_cond_add\n    return result"
        }
    ]
}