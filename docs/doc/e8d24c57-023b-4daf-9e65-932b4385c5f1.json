{
    "summary": "The code utilizes EfficientNet models in Keras for image classification tasks, providing custom architecture options and preprocessing using the film_efficientnet library.",
    "details": [
        {
            "comment": "This code is a part of EfficientNet models with added film layers, copied from the original efficientnet.py file. It includes copyright and license information, skips file checks, and imports necessary modules. BASE_WEIGHTS_PATH points to the directory for EfficientNet checkpoints.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":0-33",
            "content": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# pytype: skip-file\n# pylint: skip-file\n\"\"\"EfficientNet models modified with added film layers.\nMostly copied from third_party/py/keras/applications/efficientnet.py\n\"\"\"\nimport copy\nimport math\nimport os\nimport warnings\nimport json\nfrom absl import logging\nimport tensorflow.compat.v2 as tf\nfrom tensorflow.keras import layers\nfrom robotics_transformer.film_efficientnet.film_conditioning_layer import FilmConditioning\nBASE_WEIGHTS_PATH = 'efficientnet_checkpoints/efficientnet'"
        },
        {
            "comment": "The code defines the path to the Imagenet classes JSON file, dictionary of weights paths for different models, and default block arguments for the EfficientNet model's encoder.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":34-83",
            "content": "IMAGENET_JSON_PATH = 'efficientnet_checkpoints/imagenet_classes.json'\nCLASS_INDEX = None\nWEIGHTS_PATHS = {\n    'efficientnetb3': BASE_WEIGHTS_PATH + 'b3.h5',\n    'efficientnetb3_notop': BASE_WEIGHTS_PATH + 'b3_notop.h5',\n}\nDEFAULT_BLOCKS_ARGS = [{\n    'kernel_size': 3,\n    'repeats': 1,\n    'filters_in': 32,\n    'filters_out': 16,\n    'expand_ratio': 1,\n    'id_skip': True,\n    'strides': 1,\n    'se_ratio': 0.25\n}, {\n    'kernel_size': 3,\n    'repeats': 2,\n    'filters_in': 16,\n    'filters_out': 24,\n    'expand_ratio': 6,\n    'id_skip': True,\n    'strides': 2,\n    'se_ratio': 0.25\n}, {\n    'kernel_size': 5,\n    'repeats': 2,\n    'filters_in': 24,\n    'filters_out': 40,\n    'expand_ratio': 6,\n    'id_skip': True,\n    'strides': 2,\n    'se_ratio': 0.25\n}, {\n    'kernel_size': 3,\n    'repeats': 3,\n    'filters_in': 40,\n    'filters_out': 80,\n    'expand_ratio': 6,\n    'id_skip': True,\n    'strides': 2,\n    'se_ratio': 0.25\n}, {\n    'kernel_size': 5,\n    'repeats': 3,\n    'filters_in': 80,\n    'filters_out': 112,\n    'expand_ratio': 6,"
        },
        {
            "comment": "This code defines a model architecture for EfficientNet in Keras. It consists of multiple convolutional layers with different parameters like kernel size, filters, and stride. The CONV_KERNEL_INITIALIZER and DENSE_KERNEL_INITIALIZER are initializers used for the convolution and dense layers respectively. The BASE_DOCSTRING provides information about the architecture and its source.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":84-132",
            "content": "    'id_skip': True,\n    'strides': 1,\n    'se_ratio': 0.25\n}, {\n    'kernel_size': 5,\n    'repeats': 4,\n    'filters_in': 112,\n    'filters_out': 192,\n    'expand_ratio': 6,\n    'id_skip': True,\n    'strides': 2,\n    'se_ratio': 0.25\n}, {\n    'kernel_size': 3,\n    'repeats': 1,\n    'filters_in': 192,\n    'filters_out': 320,\n    'expand_ratio': 6,\n    'id_skip': True,\n    'strides': 1,\n    'se_ratio': 0.25\n}]\nCONV_KERNEL_INITIALIZER = {\n    'class_name': 'VarianceScaling',\n    'config': {\n        'scale': 2.0,\n        'mode': 'fan_out',\n        'distribution': 'truncated_normal'\n    }\n}\nDENSE_KERNEL_INITIALIZER = {\n    'class_name': 'VarianceScaling',\n    'config': {\n        'scale': 1. / 3.,\n        'mode': 'fan_out',\n        'distribution': 'uniform'\n    }\n}\nBASE_DOCSTRING = \"\"\"Instantiates the {name} architecture.\n  Reference:\n  - [EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks](\n      https://arxiv.org/abs/1905.11946) (ICML 2019)\n  This function returns a Keras image classification model,\n  optionally loaded with weights pre-trained on ImageNet."
        },
        {
            "comment": "The code snippet provides information about the usage of EfficientNet for image classification and transfer learning, specifying that it includes input preprocessing as part of the model. It also notes that EfficientNet models expect inputs in the [0-255] range as float tensors. The code accepts arguments for including the fully-connected layer at the top and loading specific weights.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":134-155",
            "content": "  For image classification use cases, see\n  [this page for detailed examples](\n    https://keras.io/api/applications/#usage-examples-for-image-classification-models).\n  For transfer learning use cases, make sure to read the\n  [guide to transfer learning & fine-tuning](\n    https://keras.io/guides/transfer_learning/).\n  Note: each Keras Application expects a specific kind of input preprocessing.\n  For EfficientNet, input preprocessing is included as part of the model\n  (as a `Rescaling` layer), and thus\n  `tf.keras.applications.efficientnet.preprocess_input` is actually a\n  pass-through function. EfficientNet models expect their inputs to be float\n  tensors of pixels with values in the [0-255] range.\n  Args:\n    include_top: Whether to include the fully-connected\n        layer at the top of the network. Defaults to True.\n    weights: One of `None` (random initialization),\n          'imagenet' (pre-training on ImageNet),\n          or the path to the weights file to be loaded. Defaults to 'imagenet'.\n    input_tensor: Optional Keras tensor"
        },
        {
            "comment": "This code snippet is a part of EfficientNet model's encoder in film_efficientnet library. It defines the input parameters for creating an EfficientNet model instance, including shape, pooling mode (None, avg or max), and number of classes to classify. The input shape should have exactly 3 input channels, and the model output depends on the specified pooling mode.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":156-176",
            "content": "        (i.e. output of `layers.Input()`)\n        to use as image input for the model.\n    input_shape: Optional shape tuple, only to be specified\n        if `include_top` is False.\n        It should have exactly 3 inputs channels.\n    pooling: Optional pooling mode for feature extraction\n        when `include_top` is `False`. Defaults to None.\n        - `None` means that the output of the model will be\n            the 4D tensor output of the\n            last convolutional layer.\n        - `avg` means that global average pooling\n            will be applied to the output of the\n            last convolutional layer, and thus\n            the output of the model will be a 2D tensor.\n        - `max` means that global max pooling will\n            be applied.\n    classes: Optional number of classes to classify images\n        into, only to be specified if `include_top` is True, and\n        if no `weights` argument is specified. Defaults to 1000 (number of\n        ImageNet classes).\n    classifier_activation: A `str` or callable. The activation function to use"
        },
        {
            "comment": "This function is used to validate the classifier's activation and compatibility with pretrained weights. If no weights are provided, it returns without raising any issues. The function checks if the classifier activation is either 'softmax' or None, and raises a ValueError if an incompatible activation function is used with pretrained weights.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":177-209",
            "content": "        on the \"top\" layer. Ignored unless `include_top=True`. Set\n        `classifier_activation=None` to return the logits of the \"top\" layer.\n        Defaults to 'softmax'.\n        When loading pretrained weights, `classifier_activation` can only\n        be `None` or `\"softmax\"`.\n  Returns:\n    A `keras.Model` instance.\n\"\"\"\nIMAGENET_STDDEV_RGB = [0.229, 0.224, 0.225]\ndef validate_activation(classifier_activation, weights):\n  \"\"\"validates that the classifier is compatible with the weights.\n  Args:\n    classifier_activation: str or callable activation function\n    weights: The pretrained weights to load.\n  Raises:\n    ValueError: if an activation other than `None` or `softmax` are used with\n      pretrained weights.\n  \"\"\"\n  if weights is None:\n    return\n  classifier_activation = tf.keras.activations.get(classifier_activation)\n  if classifier_activation not in {\n      tf.keras.activations.get('softmax'),\n      tf.keras.activations.get(None)\n  }:\n    raise ValueError('Only `None` and `softmax` activations are allowed '"
        },
        {
            "comment": "The code contains a function 'correct_pad' that returns the padding for 2D convolution with downsampling. It takes inputs and kernel size as arguments and returns a tuple of the correct padding. The function also checks if input size is None or not, adjusts the padding accordingly, and calculates the final padding values. The 'obtain_input_shape' function takes an input shape and calls the 'correct_pad' function to obtain the input shape for 2D convolution.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":210-238",
            "content": "                     'for the `classifier_activation` argument when using '\n                     'pretrained weights, with `include_top=True`; Received: '\n                     f'classifier_activation={classifier_activation}')\ndef correct_pad(inputs, kernel_size):\n  \"\"\"Returns a tuple for zero-padding for 2D convolution with downsampling.\n  Args:\n    inputs: Input tensor.\n    kernel_size: An integer or tuple/list of 2 integers.\n  Returns:\n    A tuple.\n  \"\"\"\n  img_dim = 2 if tf.keras.backend.image_data_format() == 'channels_first' else 1\n  input_size = tf.keras.backend.int_shape(inputs)[img_dim:(img_dim + 2)]\n  if isinstance(kernel_size, int):\n    kernel_size = (kernel_size, kernel_size)\n  if input_size[0] is None:\n    adjust = (1, 1)\n  else:\n    adjust = (1 - input_size[0] % 2, 1 - input_size[1] % 2)\n  correct = (kernel_size[0] // 2, kernel_size[1] // 2)\n  return ((correct[0] - adjust[0], correct[0]), (correct[1] - adjust[1],\n                                                 correct[1]))\ndef obtain_input_shape(input_shape,"
        },
        {
            "comment": "This code defines a utility function to compute or validate the input shape of a model. It takes in arguments like input_shape, default_size, min_size, data_format, require_flatten, and weights. The function returns an integer shape tuple and raises ValueError for invalid argument values. If weights is 'imagenet', it checks if input channels are equal to 3.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":239-264",
            "content": "                       default_size,\n                       min_size,\n                       data_format,\n                       require_flatten,\n                       weights=None):\n  \"\"\"Internal utility to compute/validate a model's input shape.\n  Args:\n    input_shape: Either None (will return the default network input shape), or a\n      user-provided shape to be validated.\n    default_size: Default input width/height for the model.\n    min_size: Minimum input width/height accepted by the model.\n    data_format: Image data format to use.\n    require_flatten: Whether the model is expected to be linked to a classifier\n      via a Flatten layer.\n    weights: One of `None` (random initialization) or 'imagenet' (pre-training\n      on ImageNet). If weights='imagenet' input channels must be equal to 3.\n  Returns:\n    An integer shape tuple (may include None entries).\n  Raises:\n    ValueError: In case of invalid argument values.\n  \"\"\"\n  if weights != 'imagenet' and input_shape and len(input_shape) == 3:\n    if data_format == 'channels_first':"
        },
        {
            "comment": "The code checks if the input shape contains 1 or 3 channels for both the first and last dimensions. If not, it raises a warning. It then assigns a default shape based on whether the data format is 'channels_first' or 'channels_last'. Finally, it checks if weights are set to 'imagenet' and requires flattening. If so, it raises an error if the input shape does not match the expected default shape.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":265-288",
            "content": "      if input_shape[0] not in {1, 3}:\n        warnings.warn(\n            'This model usually expects 1 or 3 input channels. '\n            'However, it was passed an input_shape with ' +\n            str(input_shape[0]) + ' input channels.',\n            stacklevel=2)\n      default_shape = (input_shape[0], default_size, default_size)\n    else:\n      if input_shape[-1] not in {1, 3}:\n        warnings.warn(\n            'This model usually expects 1 or 3 input channels. '\n            'However, it was passed an input_shape with ' +\n            str(input_shape[-1]) + ' input channels.',\n            stacklevel=2)\n      default_shape = (default_size, default_size, input_shape[-1])\n  else:\n    if data_format == 'channels_first':\n      default_shape = (3, default_size, default_size)\n    else:\n      default_shape = (default_size, default_size, 3)\n  if weights == 'imagenet' and require_flatten:\n    if input_shape is not None:\n      if input_shape != default_shape:\n        raise ValueError('When setting `include_top=True` '"
        },
        {
            "comment": "This code raises a ValueError if the input shape is not correct. If 'imagenet' weights are loaded, default input shape is used, and it expects three channels. If input shape has less than three channels, or its width/height is less than min_size, then a ValueError is raised.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":289-309",
            "content": "                         'and loading `imagenet` weights, '\n                         f'`input_shape` should be {default_shape}.  '\n                         f'Received: input_shape={input_shape}')\n    return default_shape\n  if input_shape:\n    if data_format == 'channels_first':\n      if input_shape is not None:\n        if len(input_shape) != 3:\n          raise ValueError('`input_shape` must be a tuple of three integers.')\n        if input_shape[0] != 3 and weights == 'imagenet':\n          raise ValueError('The input must have 3 channels; Received '\n                           f'`input_shape={input_shape}`')\n        if ((input_shape[1] is not None and input_shape[1] < min_size) or\n            (input_shape[2] is not None and input_shape[2] < min_size)):\n          raise ValueError(f'Input size must be at least {min_size}'\n                           f'x{min_size}; Received: '\n                           f'input_shape={input_shape}')\n    else:\n      if input_shape is not None:\n        if len(input_shape) != 3:\n          raise ValueError('`input_shape` must be a tuple of three integers.')"
        },
        {
            "comment": "The code checks if the input shape has 3 channels and is at least the minimum size. If not, it raises a ValueError. If 'include_top' is True, it requires a static input shape. It returns the adjusted input shape based on data format and whether flattening is required.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":310-335",
            "content": "        if input_shape[-1] != 3 and weights == 'imagenet':\n          raise ValueError('The input must have 3 channels; Received '\n                           f'`input_shape={input_shape}`')\n        if ((input_shape[0] is not None and input_shape[0] < min_size) or\n            (input_shape[1] is not None and input_shape[1] < min_size)):\n          raise ValueError('Input size must be at least '\n                           f'{min_size}x{min_size}; Received: '\n                           f'input_shape={input_shape}')\n  else:\n    if require_flatten:\n      input_shape = default_shape\n    else:\n      if data_format == 'channels_first':\n        input_shape = (3, None, None)\n      else:\n        input_shape = (None, None, 3)\n  if require_flatten:\n    if None in input_shape:\n      raise ValueError('If `include_top` is True, '\n                       'you should specify a static `input_shape`. '\n                       f'Received: input_shape={input_shape}')\n  return input_shape\ndef EfficientNet(width_coefficient,\n                 depth_coefficient,"
        },
        {
            "comment": "This code is defining a function that instantiates an EfficientNet architecture using given scaling coefficients. It takes arguments for width and depth coefficient, default input image size, dropout rate, and other parameters to customize the network's structure. The function returns an instance of the EfficientNet model.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":336-360",
            "content": "                 default_size,\n                 dropout_rate=0.2,\n                 drop_connect_rate=0.2,\n                 depth_divisor=8,\n                 activation='swish',\n                 blocks_args='default',\n                 model_name='efficientnet',\n                 include_top=True,\n                 weights='imagenet',\n                 input_tensor=None,\n                 input_shape=None,\n                 pooling=None,\n                 classes=1000,\n                 classifier_activation='softmax',\n                 include_film=False):\n  \"\"\"Instantiates the EfficientNet architecture using given scaling coefficients.\n  Args:\n    width_coefficient: float, scaling coefficient for network width.\n    depth_coefficient: float, scaling coefficient for network depth.\n    default_size: integer, default input image size.\n    dropout_rate: float, dropout rate before final classifier layer.\n    drop_connect_rate: float, dropout rate at skip connections.\n    depth_divisor: integer, a unit of network width.\n    activation: activation function."
        },
        {
            "comment": "This function takes in parameters for constructing blocks, model name, inclusion of top layers, weights to be used, input tensor, input shape and pooling mode, which are then used to create a film efficientnet encoder model.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":361-376",
            "content": "    blocks_args: list of dicts, parameters to construct block modules.\n    model_name: string, model name.\n    include_top: whether to include the fully-connected layer at the top of the\n      network.\n    weights: one of `None` (random initialization), 'imagenet' (pre-training on\n      ImageNet), or the path to the weights file to be loaded.\n    input_tensor: optional Keras tensor (i.e. output of `layers.Input()`) to use\n      as image input for the model.\n    input_shape: optional shape tuple, only to be specified if `include_top` is\n      False. It should have exactly 3 inputs channels.\n    pooling: optional pooling mode for feature extraction when `include_top` is\n      `False`. - `None` means that the output of the model will be the 4D tensor\n      output of the last convolutional layer. - `avg` means that global average\n      pooling will be applied to the output of the last convolutional layer, and\n      thus the output of the model will be a 2D tensor. - `max` means that\n      global max pooling will be applied."
        },
        {
            "comment": "This code defines a model using EfficientNet as the encoder and allows for optional classification into a specific number of classes. It includes an option to insert film conditioning layers, and can be initialized with random values or pre-trained on ImageNet. The classifier activation function can also be specified.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":377-400",
            "content": "    classes: optional number of classes to classify images into, only to be\n      specified if `include_top` is True, and if no `weights` argument is\n      specified.\n    classifier_activation: A `str` or callable. The activation function to use\n      on the \"top\" layer. Ignored unless `include_top=True`. Set\n      `classifier_activation=None` to return the logits of the \"top\" layer.\n    include_film: bool, whether or not to insert film conditioning layers.\n  Returns:\n    A `keras.Model` instance.\n  Raises:\n    ValueError: in case of invalid argument for `weights`,\n      or invalid input shape.\n    ValueError: if `classifier_activation` is not `softmax` or `None` when\n      using a pretrained top layer.\n  \"\"\"\n  if blocks_args == 'default':\n    blocks_args = DEFAULT_BLOCKS_ARGS\n  if not (weights in {'imagenet', None} or tf.io.gfile.exists(weights)):\n    raise ValueError('The `weights` argument should be either '\n                     '`None` (random initialization), `imagenet` '\n                     '(pre-training on ImageNet), '"
        },
        {
            "comment": "This code is initializing the EfficientNet model for image classification with optional context input and weights loading. It determines the proper input shape, creates the input layers for image and context data, and defines a function to round the number of filters based on divisor.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":401-429",
            "content": "                     'or the path to the weights file to be loaded.')\n  if weights == 'imagenet' and include_top and classes != 1000:\n    raise ValueError('If using `weights` as `\"imagenet\"` with `include_top`'\n                     ' as true, `classes` should be 1000')\n  # Determine proper input shape\n  input_shape = obtain_input_shape(\n      input_shape,\n      default_size=default_size,\n      min_size=32,\n      data_format=tf.keras.backend.image_data_format(),\n      require_flatten=include_top,\n      weights=weights)\n  if include_film:\n    with tf.compat.v1.variable_scope('context_input'):\n      context_input = layers.Input(shape=512)\n  if input_tensor is None:\n    img_input = layers.Input(shape=input_shape)\n  else:\n    if not tf.keras.backend.is_keras_tensor(input_tensor):\n      img_input = layers.Input(tensor=input_tensor, shape=input_shape)\n    else:\n      img_input = input_tensor\n  bn_axis = 3 if tf.keras.backend.image_data_format() == 'channels_last' else 1\n  def round_filters(filters, divisor=depth_divisor):"
        },
        {
            "comment": "The code rounds the number of filters based on a depth multiplier to ensure it doesn't decrease by more than 10%. It also rounds the number of repeats for better efficiency. The code normalizes input data and applies transformation to match the original implementation, even when not using Imagenet weights.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":430-452",
            "content": "    \"\"\"Round number of filters based on depth multiplier.\"\"\"\n    filters *= width_coefficient\n    new_filters = max(divisor, int(filters + divisor / 2) // divisor * divisor)\n    # Make sure that round down does not go down by more than 10%.\n    if new_filters < 0.9 * filters:\n      new_filters += divisor\n    return int(new_filters)\n  def round_repeats(repeats):\n    \"\"\"Round number of repeats based on depth multiplier.\"\"\"\n    return int(math.ceil(depth_coefficient * repeats))\n  # Build stem\n  x = img_input\n  x = layers.Rescaling(1. / 255.)(x)\n  x = layers.Normalization(axis=bn_axis)(x)\n  # Note that the normaliztion layer uses square value of STDDEV as the\n  # variance for the layer: result = (input - mean) / sqrt(var)\n  # However, the original implemenetation uses (input - mean) / var to\n  # normalize the input, we need to divide another sqrt(var) to match the\n  # original implementation.\n  # See https://github.com/tensorflow/tensorflow/issues/49930 for more details\n  # We always apply this transformation, even when not using imagenet weights,"
        },
        {
            "comment": "This code snippet initializes the EfficientNet model by preprocessing input data, applying a Conv2D layer, batch normalization, and activation function. It also creates blocks using given arguments and updates filters based on depth multiplier.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":453-481",
            "content": "  # because it needs to be in the graph when grafting weights from imagenet\n  # pretrained models.\n  x = layers.Rescaling(1. / tf.math.sqrt(IMAGENET_STDDEV_RGB))(x)\n  x = layers.ZeroPadding2D(padding=correct_pad(x, 3), name='stem_conv_pad')(x)\n  x = layers.Conv2D(\n      round_filters(32),\n      3,\n      strides=2,\n      padding='valid',\n      use_bias=False,\n      kernel_initializer=CONV_KERNEL_INITIALIZER,\n      name='stem_conv')(\n          x)\n  x = layers.BatchNormalization(axis=bn_axis, name='stem_bn')(x)\n  x = layers.Activation(activation, name='stem_activation')(x)\n  # Build blocks\n  blocks_args = copy.deepcopy(blocks_args)\n  b = 0\n  blocks = float(sum(round_repeats(args['repeats']) for args in blocks_args))\n  for (i, args) in enumerate(blocks_args):\n    assert args['repeats'] > 0\n    # Update block input and output filters based on depth multiplier.\n    args['filters_in'] = round_filters(args['filters_in'])\n    args['filters_out'] = round_filters(args['filters_out'])\n    for j in range(round_repeats(args.pop('repeats'))):"
        },
        {
            "comment": "Code block builds an EfficientNet encoder with blocks of various sizes, applying activation functions and optional Film conditioning. It then applies a Conv2D layer, BatchNormalization, Activation, GlobalAveragePooling2D (if include_top is True), and potentially Dropout (if dropout_rate is greater than 0).",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":482-512",
            "content": "      # The first block needs to take care of stride and filter size increase.\n      if j > 0:\n        args['strides'] = 1\n        args['filters_in'] = args['filters_out']\n      x = block(\n          x,\n          activation,\n          drop_connect_rate * b / blocks,\n          name='block{}{}_'.format(i + 1, chr(j + 97)),\n          **args)\n      if include_film:\n        with tf.compat.v1.variable_scope('film_conditioning'):\n          x = FilmConditioning(num_channels=x.shape[-1])(x, context_input)\n      b += 1\n  # Build top\n  x = layers.Conv2D(\n      round_filters(1280),\n      1,\n      padding='same',\n      use_bias=False,\n      kernel_initializer=CONV_KERNEL_INITIALIZER,\n      name='top_conv')(\n          x)\n  x = layers.BatchNormalization(axis=bn_axis, name='top_bn')(x)\n  x = layers.Activation(activation, name='top_activation')(x)\n  if include_top:\n    x = layers.GlobalAveragePooling2D(name='avg_pool')(x)\n    if dropout_rate > 0:\n      x = layers.Dropout(dropout_rate, name='top_dropout')(x)\n    validate_activation(classifier_activation, weights)"
        },
        {
            "comment": "This code snippet is part of a model construction process. It creates a dense layer with the specified number of classes, applies activation function, and initializes kernel with a specific value. Depending on the pooling method, it uses GlobalAveragePooling2D or GlobalMaxPooling2D. It ensures that the model considers any potential predecessors of input_tensor. It creates a model using tf.keras.Model, specifying inputs and output. If weights are specified as 'imagenet', it loads weights accordingly; otherwise, if weights are provided, it loads them.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":513-546",
            "content": "    x = layers.Dense(\n        classes,\n        activation=classifier_activation,\n        kernel_initializer=DENSE_KERNEL_INITIALIZER,\n        name='predictions')(\n            x)\n  else:\n    if pooling == 'avg':\n      x = layers.GlobalAveragePooling2D(name='avg_pool')(x)\n    elif pooling == 'max':\n      x = layers.GlobalMaxPooling2D(name='max_pool')(x)\n  # Ensure that the model takes into account\n  # any potential predecessors of `input_tensor`.\n  if input_tensor is not None:\n    inputs = tf.keras.utils.get_source_inputs(input_tensor)\n  else:\n    inputs = img_input\n    if include_film:\n      inputs = (img_input, context_input)\n  # Create model.\n  model = tf.keras.Model(inputs, x, name=model_name)\n  # Load weights.\n  if weights == 'imagenet':\n    if include_top:\n      key = model_name\n    else:\n      key = model_name + '_notop'\n    weights_path = os.path.join(os.path.dirname(__file__), WEIGHTS_PATHS[key])\n    model.load_weights(weights_path, skip_mismatch=False, by_name=False)\n  elif weights is not None:\n    model.load_weights(weights, skip_mismatch=False, by_name=False)"
        },
        {
            "comment": "This code defines an inverted residual block function, which takes inputs and various arguments such as activation function, drop rate, etc. It returns the output tensor for the block after applying convolutions, Batch Normalization, and other operations.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":547-579",
            "content": "  return model\ndef block(inputs,\n          activation='swish',\n          drop_rate=0.,\n          name='',\n          filters_in=32,\n          filters_out=16,\n          kernel_size=3,\n          strides=1,\n          expand_ratio=1,\n          se_ratio=0.,\n          id_skip=True):\n  \"\"\"An inverted residual block.\n  Args:\n      inputs: input tensor.\n      activation: activation function.\n      drop_rate: float between 0 and 1, fraction of the input units to drop.\n      name: string, block label.\n      filters_in: integer, the number of input filters.\n      filters_out: integer, the number of output filters.\n      kernel_size: integer, the dimension of the convolution window.\n      strides: integer, the stride of the convolution.\n      expand_ratio: integer, scaling coefficient for the input filters.\n      se_ratio: float between 0 and 1, fraction to squeeze the input filters.\n      id_skip: boolean.\n  Returns:\n      output tensor for the block.\n  \"\"\"\n  bn_axis = 3 if tf.keras.backend.image_data_format() == 'channels_last' else 1"
        },
        {
            "comment": "The code implements an Expansion phase, Depthwise Convolution, and Squeeze and Excitation phase in a Convolutional Neural Network (CNN) architecture. It uses Conv2D for expansion, BatchNormalization and Activation functions, and DepthwiseConv2D for depthwise convolution.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":581-616",
            "content": "  # Expansion phase\n  filters = filters_in * expand_ratio\n  if expand_ratio != 1:\n    x = layers.Conv2D(\n        filters,\n        1,\n        padding='same',\n        use_bias=False,\n        kernel_initializer=CONV_KERNEL_INITIALIZER,\n        name=name + 'expand_conv')(\n            inputs)\n    x = layers.BatchNormalization(axis=bn_axis, name=name + 'expand_bn')(x)\n    x = layers.Activation(activation, name=name + 'expand_activation')(x)\n  else:\n    x = inputs\n  # Depthwise Convolution\n  if strides == 2:\n    x = layers.ZeroPadding2D(\n        padding=correct_pad(x, kernel_size), name=name + 'dwconv_pad')(\n            x)\n    conv_pad = 'valid'\n  else:\n    conv_pad = 'same'\n  x = layers.DepthwiseConv2D(\n      kernel_size,\n      strides=strides,\n      padding=conv_pad,\n      use_bias=False,\n      depthwise_initializer=CONV_KERNEL_INITIALIZER,\n      name=name + 'dwconv')(\n          x)\n  x = layers.BatchNormalization(axis=bn_axis, name=name + 'bn')(x)\n  x = layers.Activation(activation, name=name + 'activation')(x)\n  # Squeeze and Excitation phase"
        },
        {
            "comment": "This code applies Squeeze-and-Excite (SE) block for spatial feature recalibration in the encoder part of a model. It calculates and applies a learnable spatially invariant scale to each filter, followed by convolutional layers to produce the SE effect. Then, it performs output phase with a convolution layer and batch normalization.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":617-652",
            "content": "  if 0 < se_ratio <= 1:\n    filters_se = max(1, int(filters_in * se_ratio))\n    se = layers.GlobalAveragePooling2D(name=name + 'se_squeeze')(x)\n    if bn_axis == 1:\n      se_shape = (filters, 1, 1)\n    else:\n      se_shape = (1, 1, filters)\n    se = layers.Reshape(se_shape, name=name + 'se_reshape')(se)\n    se = layers.Conv2D(\n        filters_se,\n        1,\n        padding='same',\n        activation=activation,\n        kernel_initializer=CONV_KERNEL_INITIALIZER,\n        name=name + 'se_reduce')(\n            se)\n    se = layers.Conv2D(\n        filters,\n        1,\n        padding='same',\n        activation='sigmoid',\n        kernel_initializer=CONV_KERNEL_INITIALIZER,\n        name=name + 'se_expand')(\n            se)\n    x = layers.multiply([x, se], name=name + 'se_excite')\n  # Output phase\n  x = layers.Conv2D(\n      filters_out,\n      1,\n      padding='same',\n      use_bias=False,\n      kernel_initializer=CONV_KERNEL_INITIALIZER,\n      name=name + 'project_conv')(\n          x)\n  x = layers.BatchNormalization(axis=bn_axis, name=name + 'project_bn')(x)"
        },
        {
            "comment": "This code checks if the skip connection, strides, and number of filters match certain conditions. If so, it may apply a dropout layer and adds inputs with the original input. The function creates two models: one without and one with film layers. It copies weights from the model with film layers to the model without, which is useful if inserting early film layers for proper weight restoration.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":653-682",
            "content": "  if id_skip and strides == 1 and filters_in == filters_out:\n    if drop_rate > 0:\n      x = layers.Dropout(\n          drop_rate, noise_shape=(None, 1, 1, 1), name=name + 'drop')(\n              x)\n    x = layers.add([x, inputs], name=name + 'add')\n  return x\ndef maybe_restore_with_film(\n    *args,\n    weights='imagenet',\n    include_film=False,\n    **kwargs,\n):\n  n1 = EfficientNet(*args, weights=weights, include_film=False, **kwargs)\n  if not include_film:\n    return n1\n  # Copy the model weights over to a new model. This is necessary\n  # in case we have inserted early film layers. In this case,\n  # the pretrained weights will fail to restore properly\n  # unless we do this trick.\n  n2 = EfficientNet(*args, weights=None, include_film=True, **kwargs)\n  # The layers without the film layers.\n  l1 = {l.name: l for l in n1.layers}\n  # The layers with the film layers.\n  l2 = {l.name: l for l in n2.layers}\n  for layer_name, layer in l2.items():\n    if layer_name in l1:\n      layer.set_weights(l1[layer_name].get_weights())"
        },
        {
            "comment": "The code is a function in the 'film_efficientnet_encoder.py' file that identifies and assigns weights to specific layers within the EfficientNetB3 model based on their names (rescaling or normalization). The function takes input from other functions like 'maybe_restore_with_film' and returns n2.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":683-712",
            "content": "    # Annoyingly, the rescaling and normalization layers get different names\n    # in each graph.\n    elif 'rescaling' in layer_name:\n      _, num = layer_name.split('_')\n      l1_layer_name = 'rescaling_' + str(int(num) - 2 or '')\n      l1_layer_name = l1_layer_name.rstrip('_')\n      layer.set_weights(l1[l1_layer_name].get_weights())\n    elif 'normalization' in layer_name:\n      _, num = layer_name.split('_')\n      l1_layer_name = 'normalization_' + str(int(num) - 1 or '')\n      l1_layer_name = l1_layer_name.rstrip('_')\n      layer.set_weights(l1[l1_layer_name].get_weights())\n  return n2\ndef EfficientNetB3(include_top=True,\n                   weights='imagenet',\n                   input_tensor=None,\n                   input_shape=None,\n                   pooling=None,\n                   classes=1000,\n                   classifier_activation='softmax',\n                   include_film=False,\n                   **kwargs):\n  return maybe_restore_with_film(\n      1.2,\n      1.4,\n      300,\n      0.3,\n      model_name='efficientnetb3',"
        },
        {
            "comment": "The code defines an EfficientNetB3 model with optional input shape, pooling method, and classifier activation function. The preprocess_input function is a placeholder for backward compatibility, as the preprocessing logic has been included in the efficientnet model implementation.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":713-739",
            "content": "      include_top=include_top,\n      weights=weights,\n      input_tensor=input_tensor,\n      input_shape=input_shape,\n      pooling=pooling,\n      classes=classes,\n      classifier_activation=classifier_activation,\n      include_film=include_film,\n      **kwargs)\nEfficientNetB3.__doc__ = BASE_DOCSTRING.format(name='EfficientNetB3')\ndef preprocess_input(x, data_format=None):  # pylint: disable=unused-argument\n  \"\"\"A placeholder method for backward compatibility.\n  The preprocessing logic has been included in the efficientnet model\n  implementation. Users are no longer required to call this method to normalize\n  the input data. This method does nothing and only kept as a placeholder to\n  align the API surface between old and new version of model.\n  Args:\n    x: A floating point `numpy.array` or a `tf.Tensor`.\n    data_format: Optional data format of the image tensor/array. Defaults to\n      None, in which case the global setting `tf.keras.image_data_format() is\n      used (unless you changed it, it defaults to \"channels_last\").{mode}"
        },
        {
            "comment": "Function `decode_predictions` takes in predictions and a top parameter. It sorts the top predicted indices in descending order, then creates a tuple with the class name, score, and index for each of the top predictions. The results are sorted by score in descending order and stored in the 'results' list which is returned at the end.",
            "location": "\"/media/root/Prima/works/robotics_transformer/docs/src/film_efficientnet/film_efficientnet_encoder.py\":741-758",
            "content": "  Returns:\n    Unchanged `numpy.array` or `tf.Tensor`.\n  \"\"\"\n  return x\ndef decode_predictions(preds, top=5):\n  global CLASS_INDEX\n  if CLASS_INDEX is None:\n    with open(os.path.join(os.path.dirname(__file__), IMAGENET_JSON_PATH)) as f:\n      CLASS_INDEX = json.load(f)\n  results = []\n  for pred in preds:\n    top_indices = pred.argsort()[-top:][::-1]\n    result = [tuple(CLASS_INDEX[str(i)]) + (pred[i],) for i in top_indices]\n    result.sort(key=lambda x: x[2], reverse=True)\n    results.append(result)\n  return results"
        }
    ]
}